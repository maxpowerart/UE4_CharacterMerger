#include "CharacterMergerLibrary.h"
#include "SkeletalMeshMerge.h"
#include "Rendering/SkeletalMeshRenderData.h"

USkeletalMesh* FCharacterMergerLibrary::MergeRequest(const TArray<USkeletalMesh*>& ComponentsToWeld, UPackage* Package)
{
	if (ComponentsToWeld.Num() == 0) return nullptr;

	USkeletalMesh* CompositeMesh = IsValid(Package) ? NewObject<USkeletalMesh>(Package, NAME_None, RF_Public | RF_Standalone) : NewObject<USkeletalMesh>();
	CompositeMesh->SetRefSkeleton(ComponentsToWeld[0]->GetSkeleton()->GetReferenceSkeleton());
	CompositeMesh->SetSkeleton(ComponentsToWeld[0]->GetSkeleton());
		
	TArray<FSkelMeshMergeSectionMapping> InForceSectionMapping;
	FSkeletalMeshMerge MeshMergeUtil(CompositeMesh, ComponentsToWeld, InForceSectionMapping, 0);
	if (!MeshMergeUtil.DoMerge())
	{
		check(0 && "Something went wrong");
		return nullptr;
	}
	
	for(int32 It = 0; It < ComponentsToWeld.Num(); It++)
	{
		ParseMorphs(ComponentsToWeld[It], CompositeMesh);
	}
	return CompositeMesh;
}

void FCharacterMergerLibrary::ParseMorphs(USkeletalMesh* Source, USkeletalMesh* Target, int32 SourceInTargetSection)
{
	/**Collect morph targets data from source*/
	TMap<FName, TArray<FMorphTargetDelta>> SourceMorphTargets;
	for(const UMorphTarget* SourceMT : Source->GetMorphTargets())
	{
		FName SourceMTName = SourceMT->GetFName();
		SourceMorphTargets.Add(SourceMTName);
		
		for(const FMorphTargetDelta& TargetDelta : SourceMT->MorphLODModels[0].Vertices)
		{
			SourceMorphTargets[SourceMTName].Add(TargetDelta);
		}
	}

	/**Create new morph target objects*/
	TArray<UMorphTarget*> MorphTargetObjects;
	FSkeletalMeshLODRenderData& RenderData = Target->GetResourceForRendering()->LODRenderData[0];
	for(const TTuple<FName, TArray<FMorphTargetDelta>>& MorphTarget : SourceMorphTargets)
	{
		TArray<FName> ExistingMorphs;
		Target->GetMorphTargetIndexMap().GetKeys(ExistingMorphs);
		UMorphTarget* NewMorphTarget = nullptr;

		/**Check, if morph with this target is already exist (for ex, in other meshes)*/
		if(!ExistingMorphs.Contains(MorphTarget.Key))
		{
			NewMorphTarget = NewObject<UMorphTarget>(Target, MorphTarget.Key);
			NewMorphTarget->MorphLODModels.AddDefaulted(1);
		}
		else
		{
			/**Search existing MT*/
			for(UMorphTarget* It : Target->GetMorphTargets())
			{
				if(It->GetFName() == MorphTarget.Key)
				{
					NewMorphTarget = It;
					break;
				}
			}
		}
		
		// morph mesh data to modify
		FMorphTargetLODModel& MorphModel = NewMorphTarget->MorphLODModels[0];
		// copy the wedge point indices
		// for now just keep every thing 

		//Increase MorphModel vertex num
		MorphModel.NumBaseMeshVerts += MorphTarget.Value.Num();

		// mark if generated by reduction setting, so that we can remove them later if we want to
		// we don't want to delete if it has been imported
		MorphModel.bGeneratedByEngine = true;

		// Still keep this (could remove in long term due to incoming data)
		for (const FMorphTargetDelta& Delta : MorphTarget.Value)
		{
			if (Delta.PositionDelta.SizeSquared() > FMath::Square(THRESH_POINTS_ARE_NEAR))
			{
				MorphModel.Vertices.Add(Delta);
				for (int32 SectionIdx = 0; SectionIdx < RenderData.RenderSections.Num(); ++SectionIdx)
				{
					if (MorphModel.SectionIndices.Contains(SectionIdx))
					{
						continue;
					}
						
					/**Vertex mapping, if this is not a first section -> move it to NewSection.first value*/
					const uint32 BaseVertexBufferIndex = (uint32)(RenderData.RenderSections[SectionIdx].GetVertexBufferIndex());
					const uint32 LastVertexBufferIndex = (uint32)(BaseVertexBufferIndex + RenderData.RenderSections[SectionIdx].GetNumVertices());
					if (BaseVertexBufferIndex <= Delta.SourceIdx && Delta.SourceIdx < LastVertexBufferIndex)
					{
						MorphModel.SectionIndices.AddUnique(SectionIdx);
						break;
					}
				}
			}
		}

		// sort the array of vertices for this morph target based on the base mesh indices
		// that each vertex is associated with. This allows us to sequentially traverse the list
		// when applying the morph blends to each vertex.
		MorphModel.Vertices.Sort(FCompareMorphTargetDeltas());

		// remove array slack
		MorphModel.Vertices.Shrink();

		MorphTargetObjects.Add(NewMorphTarget);
	}

	/**Wait until render thread complete commands*/
	FlushRenderingCommands();

	/**Init morph targets on target mesh*/
	Target->SetMorphTargets(MorphTargetObjects);
	Target->InitMorphTargets();
	Target->GetResourceForRendering()->ReleaseResources();
	Target->InitResources();
}
